package lesson1.hw;

/**
 * Алгоритмы_и_структуры_данных_на_Java.БазовыйКурс. 24.09.2019 Webinar.
 * Teacher: Фанзиль Кусяпкулов
 * Урок 1. Общие сведения об алгоритмах и структурах данных
 * Домашняя работа.
 * @author Litvinenko Yuriy
 * Задачи на http://acmp.ru
 * Тема. Двумерные массивы.
 * DONE ЗАДАЧА №265. Шахматная доска (Время: 1 сек. Память: 16 Мб Сложность: 26%)
 * Из шахматной доски по границам клеток выпилили связную (не распадающуюся на части)
 * фигуру без дыр. Требуется определить ее периметр.
 * Входные данные:
 * Во входном файле INPUT.TXT сначала записано число N (1 ≤ N ≤ 64) – количество выпиленных клеток.
 * В следующих N строках указаны координаты выпиленных клеток, разделенные пробелом
 * (номер строки и столбца – числа от 1 до 8). Каждая выпиленная клетка указывается один раз.
 * Выходные данные:
 * В выходной файл OUTPUT.TXT выведите одно число – периметр выпиленной фигуры (сторона клетки равна единице).
 * Примеры:
 * 3
 * 1 1
 * 1 2
 * 2 1            >> 8
 * 1
 * 8 8            >> 4
 * Формализованная задача.
 * Суммируем стороны ячейки, если это крайняя сторона или нет соседа.
 */

import java.io.PrintWriter;
import java.util.Scanner;

public class Acmp0265 {
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        //инициируем переменную периметра
        int perimeter = 0;//минимальный размер периметра из одной клетки
        int cellSize = 1;

        //принимаем количество выпеленных ячеек
        int num = in.nextInt();
        //инициируем массив для координат ячеек
        int[][] holes = new int[num][2];

        //принимаем в цикле координаты ячеек и заполняем массив
        for (int i = 0; i < holes.length; i++) {
            for (int j = 0; j < holes[0].length; j++) {
                holes[i][j] = in.nextInt();
            }
        }

        //вычисляем длину максимально возможного периода
        perimeter = num * cellSize * 4;
        //листаем массив сравниваем текущий элемент
        for (int i = 0; i < holes.length; i++) {
            //листаем массив сравниваем с остальными элементами
            for (int j = 0; j < holes.length; j++) {
                //проверяем не своя ли ячейка
                if(i != j){
                    //и есть ли сосед сверху(колонки равны,
                    if(holes[i][1] == holes[j][1]) {
                        //а строка меньше на 1)
                        if (holes[i][0] - holes[j][0] == 1) {
                            //если нет соседа, увеличиваем периметр на величину стороны
                            perimeter -= cellSize;
                        }
                        //проверяем есть ли сосед снизу(колонки равны, а строка больше на 1)
                        if(holes[j][0] - holes[i][0] == 1){
                            //если нет соседа, увеличиваем периметр на величину стороны
                            perimeter -= cellSize;
                        }
                    }
                    //и есть ли сосед слева(строки равны,
                    if(holes[i][0] == holes[j][0]) {
                        //а колонка меньше на 1)
                        if (holes[i][1] - holes[j][1] == 1) {
                            //если нет соседа, увеличиваем периметр на величину стороны
                            perimeter -= cellSize;
                        }
                        //проверяем есть ли сосед справа(строки равны, а колонка больше на 1)
                        if(holes[j][1] - holes[i][1] == 1){
                            //если нет соседа, увеличиваем периметр на величину стороны
                            perimeter -= cellSize;
                        }
                    }
                }
            }
        }
        out.println(perimeter);
        out.flush();
    }
}


//TODO временно
//out.println("holes.length: " + holes.length);
//out.println("holes[0].length: " + holes[0].length);

//TODO временно
        /*for (int[] h : holes) {
            for (int c: h) {
                out.print(c + " ");
            }
            out.println();
        }*/