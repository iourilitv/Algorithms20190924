package lesson2.hw;

/**
 * Алгоритмы_и_структуры_данных_на_Java.БазовыйКурс. 24.09.2019 Webinar.
 * Teacher: Фанзиль Кусяпкулов
 * Урок 1. Общие сведения об алгоритмах и структурах данных
 * Домашняя работа.
 * @author Litvinenko Yuriy
 * Задачи на http://acmp.ru
 * Тема. Двумерные массивы.
 * ЗАДАЧА №802. Магический квадрат (Время: 1 сек. Память: 16 Мб Сложность: 70%)
 * Магический квадрат - это квадратная таблица N x N, заполненная N2 числами от 1 до N2 таким образом,
 * что сумма чисел в каждой строке, каждом столбце и на обеих диагоналях одинакова.
 * При этом числа в таблице не должны повторяться и каждое из чисел от 1 до N^2 должно в ней
 * присутствовать. Требуется написать программу, которая по заданному N строит магический квадрат.
 * Входные данные:
 * Во входном файле INPUT.TXT задано единственное натуральное
 * число N - размерность магического квадрата (N ≤ 1000).
 * Выходные данные:
 * В выходной файл OUTPUT.TXT необходимо вывести магический квадрат - матрицу,
 * состоящую из N строк по N элементов в каждой. Если вариантов решения несколько,
 * то можно вывести любой. В том случае, когда решение не существует, следует вывести "Impossible".
 * Примеры:
 * 1 >> 1
 * 2 >> Impossible
 * 3 >> 4 9 2
 *      3 5 7
 *      8 1 6
 * Формализованная задача.
 *
 */

import java.io.PrintWriter;
import java.util.Scanner;

public class Acmp0802 {
    public static void main(String[] args){
        int n = 6;
        int[][] square = new int[n][n];
        int[] lineSums = new int[n];
        int count = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < n; j++) {
                square[i][j] = count++;
            }
        }
        /*for (int i = 0; i < n; i++) {
                lineSums[i] = i + 1;
            for (int j = 1; j < n / 2; j++) {
                lineSums[i] += (j % 2 == 0) ? (n * 2 * j) : (n * 2 * j + 1);
                // + (n * 2 * 1) + (n * 2 * 1 + 1) + (n * 2 * 2) + (n * 2 * 2 + 1) + (n * 2 * 3);
            }
            // 6 >> 1 .. 36
            // 1+12+13+24+25+36=111
            // 2+11+14+23+26+35=111
            // 3+10+15+22+27+34=111
            // 4+ 9+16+21+28+33=111
            // 5+ 8+17+20+29+32=111
            // 6+ 7+18+19+30+31=111
            //
            // lineSum = (1) + (n * 2 * 1) + (n * 2 * 1 + 1) + (n * 2 * 2) + (n * 2 * 2 + 1) + (n * 2 * 3);
            //            1        12               13               24              25            36



            //int lineSum = (i) + (n * 2 * 1) + (n * 2 * 1 + 1) + (n * 2 * 2) + (n * 2 * 2 + 1) + (n * 2 * 3) + (n * 2 * 2 + 1);
        }*/

        /*for (int i = 1; i <= n; i++) {
            for (int j = 0; j < n; j++) {
                lineSum = (i) + (n * 2 * 1) + (n * 2 * 1 + 1) + (n * 2 * 2) + (n * 2 * 2 + 1) + (n * 2 * 3) + (n * 2 * 2 + 1);
            }
        }*/

        //System.out.println(n + ": " + lineSum);
        /*Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);
        //инициируем переменную периметра
        int perimeter = 0;//минимальный размер периметра из одной клетки
        int cellSize = 1;

        //принимаем количество выпеленных ячеек
        int num = in.nextInt();
        //инициируем массив для координат ячеек
        int[][] holes = new int[num][2];

        //принимаем в цикле координаты ячеек и заполняем массив
        for (int i = 0; i < holes.length; i++) {
            for (int j = 0; j < holes[0].length; j++) {
                holes[i][j] = in.nextInt();
            }
        }

        //вычисляем длину максимально возможного периода
        perimeter = num * cellSize * 4;
        //листаем массив сравниваем текущий элемент
        for (int i = 0; i < holes.length; i++) {
            //листаем массив сравниваем с остальными элементами
            for (int j = 0; j < holes.length; j++) {
                //проверяем не своя ли ячейка
                if(i != j){
                    //и есть ли сосед сверху(колонки равны,
                    if(holes[i][1] == holes[j][1]) {
                        //а строка меньше на 1)
                        if (holes[i][0] - holes[j][0] == 1) {
                            //если нет соседа, увеличиваем периметр на величину стороны
                            perimeter -= cellSize;
                        }
                        //проверяем есть ли сосед снизу(колонки равны, а строка больше на 1)
                        if(holes[j][0] - holes[i][0] == 1){
                            //если нет соседа, увеличиваем периметр на величину стороны
                            perimeter -= cellSize;
                        }
                    }
                    //и есть ли сосед слева(строки равны,
                    if(holes[i][0] == holes[j][0]) {
                        //а колонка меньше на 1)
                        if (holes[i][1] - holes[j][1] == 1) {
                            //если нет соседа, увеличиваем периметр на величину стороны
                            perimeter -= cellSize;
                        }
                        //проверяем есть ли сосед справа(строки равны, а колонка больше на 1)
                        if(holes[j][1] - holes[i][1] == 1){
                            //если нет соседа, увеличиваем периметр на величину стороны
                            perimeter -= cellSize;
                        }
                    }
                }
            }
        }
        out.println(perimeter);
        out.flush();*/
    }
}
/*
   3 >> 4 9 2
 *      3 5 7
 *      8 1 6
 1+9+5=15
 2+7+6=15
 3+8+4=15

 */

//4 >> 1 .. 16
// 1+16+2+15=34
// 3+14+4+13=34
// 5+12+6+11=34
// 7+10+8+9=34

//05 09 02 __
//03 06 __ __
//__ 01 07 __
//__ 10 __ 08
//   26      ^<26

/*
 5 >> 1 .. 25
 1+10+11+20+21=63
 2+ 9+12+19+22=64
 3+ 8+13+18+23=65 average
 4+ 7+14+17+24=66
 5+ 6+15+16+25=67

 1+25+ 6+20+11=63
 2+24+ 7+19+12=64
 3+23+ 8+18+13=65 average
 4+22+ 9+17+14=66
 5+21+10+16+15=67
 Impossible?
 */

/*
 6 >> 1 .. 36
 1+12+13+24+25+36=111
 2+11+14+23+26+35=111
 3+10+15+22+27+34=111
 4+ 9+16+21+28+33=111
 5+ 8+17+20+29+32=111
 6+ 7+18+19+30+31=111

 lineSum = (1) + (n * 2 * 1) + (n * 2 * 1 + 1) + (n * 2 * 2) + (n * 2 * 2 + 1) + (n * 2 * 3);
            1        12               13               24              25            36
 */

/*
 7 >> 1 .. 49
 1+12+13+24+25+36=111
 2+11+14+23+26+35=111
 3+10+15+22+27+34=111
 4+ 9+16+21+28+33=111
 5+ 8+17+20+29+32=111
 6+ 7+18+19+30+31=111

int lineSum = (1) + (n * 2 * 1) + (n * 2 * 1 + 1) + (n * 2 * 2) + (n * 2 * 2 + 1) + (n * 2 * 3) + (n * 2 * 2 + 1)
            1        14               15               28              29            42               43
7: 158

 */

//TODO временно
//out.println("holes.length: " + holes.length);
//out.println("holes[0].length: " + holes[0].length);

//TODO временно
        /*for (int[] h : holes) {
            for (int c: h) {
                out.print(c + " ");
            }
            out.println();
        }*/